<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
<title>Gema</title>
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<link href="style.css" rel="stylesheet" type="text/css">
<style type="text/css">
<!--
.b16 {
	font-size: 16pt;
	font-weight: bold;
}

.a0 {
	font-family: Arial, Helvetica, sans-serif;
	font-size: 16pt;
	font-weight: bold;
	text-decoration: none;
	color: #333366;
}

.a1 {
	font-family: Arial, Helvetica, sans-serif;
	font-size: 16pt;
	font-weight: bold;
	text-decoration: underline;
	color: #990000;
}
-->
</style>
<script language="JavaScript">
var s="<a href=\""
var r="mail"
function a(w,x,y)
{ t=y+"@"+x+"."+w;  document.write(s+r+"to:"+t+"\">")}  
</script>
</head>
<body>
<table width="100%" border="0" cellspacing="0" cellpadding="1">
  <tr> 
    <td width="240" height="62" valign="top" background="topbkg1.gif"><img src="logo2.jpg" width="265" height="52"></td>
    <td width="45" background="topbkg2.gif">&nbsp;</td>
    <td align="center" valign="middle" background="topbkg3.gif"><font size=-1>&nbsp;<br>
      </font> | <a href="index.html" onMouseOut="this.className='a0'" onMouseOver="this.className='a1'" class="a0">About</a> 
      | <a href="dnld.html" onMouseOut="this.className='a0'" onMouseOver="this.className='a1'" class="a0">Downloads</a> 
      | <a href="docs.html" onMouseOut="this.className='a0'" onMouseOver="this.className='a1'" class="a0">Documents</a> 
      | <a href="links.html" onMouseOut="this.className='a0'" onMouseOver="this.className='a1'" class="a0">Links</a> 
      |</td>
  </tr>
</table>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
  <tr> 
    <td valign="top" class="tr">
      <br>
      <H1 align="center">Gema manual page</H1>
<p align="center"><a name="0"></a></h1> |&nbsp;<a href="#nam">Name</a> |&nbsp;<a href="#syn">Synopsis</a> 
|&nbsp;<a href="#des">Description</a> |&nbsp;<a href="#tut">Tutorial</a> |&nbsp;<a href="#opt">Options</a> 
|&nbsp;<a href="#pat">Patterns</a> |&nbsp;<a href="#esc">Escape sequences</a> 
|&nbsp;<a href="#rec">Recognizers</a> |&nbsp;<a href="#fun">Gema functions</a> 
|&nbsp;<a href="#bug">Bugs</a> |&nbsp;<a href="#see">See also</a> |&nbsp;<a href="#aut">Authors</a>&nbsp;| </p>
<h2>NAME<a name="nam"></a> <a href="#0" class="aa">top</a></h2>
      <p>gema - general purpose macro processor </p>
      <h2>SYNOPSIS<a name="syn"></a> <a href="#0" class="aa">top</a></h2>
      <p><tt>gema</tt> <i>options</i>... [ <i>input_file</i> [ <i>output_file</i> 
        ]] </p>
      <p><tt>gema</tt> <i>options</i>... <tt>-out</tt> <i>output_file</i> <i>input_file</i>... 
      </p>
      <p><tt>gema</tt> <i>options</i>... <tt>-odir</tt> <i>output_directory</i> 
        [<tt>-otyp</tt> <i>output_suffix</i>] <i>input_file</i>... </p>
      <p>Where <i>options</i> is:<br>
        <tt>-f</tt> <i>pattern_file</i> | [<tt>-p</tt>] '<i>patterns</i>' | <tt>-ml</tt> 
        | <tt>-b</tt> | <tt>-i</tt> | <tt>-k</tt> | <tt>-line</tt> | <tt>-t</tt> 
        | <tt>-match</tt> | <tt>-w</tt> | <br>
        <tt>-idchars </tt><i>charset</i> | <tt>-filechars </tt><i>charset</i> 
        | <tt>-literal </tt><i>charset</i> | <tt>-ml</tt><br>
        <tt>-trace</tt> | <tt>-arglen </tt><i>num</i> | <tt> </tt></p>
      <p><font size="-1">(see also the <a href="#opt">options section</a> for 
        details)</font></p>
      <h2>DESCRIPTION<a name="des"></a> <a href="#0" class="aa">top</a></h2>
      <p></p>
      <tt>gema</tt> is a general purpose text processing utility based on the 
      concept of pattern matching. In general, it reads an input file and copies 
      it to an output file, while performing certain transformations to the data 
      as specified by a set of patterns defined by the user. It can be used to 
      do the sorts of things that are done by Unix utilities such as <tt>cpp</tt>, 
      <tt>grep</tt>, <tt>sed</tt>, <tt>awk</tt>, or <tt>strings</tt>. It can be 
      used as a macro processor, but it is much more general than <tt>cpp</tt> 
      or <tt>m4</tt> because it does not impose any particular syntax for what 
      a macro call looks like. Unlike utilities like <tt>sed</tt> or <tt>awk</tt>, 
      <tt>gema</tt> can deal with patterns that span multiple lines and with nested 
      constructs. It is also distinguished by being able to use multiple sets 
      of rules to be used in different contexts. </p> <p>This <tt>man</tt> page 
        provides a tutorial introduction and a brief reference summary. See the 
        user manual for a more detailed specification. </p>
      <p>If no file names are given on the command line, the program reads from 
        standard input and writes to standard output. With two file names provided, 
        it reads from the first and writes to the second. If the output file previously 
        existed, the old file is saved with a "<tt>.bak</tt>" suffix. The input 
        file and output file may be the same, in which case the program actually 
        reads from the backup file. With the <tt>-out</tt> option, it will write 
        to the designated file, concatenating the results of reading from any 
        number of input files, which may be specified by wild cards. With the 
        <tt>-odir</tt> option, it reads any number of input files, creating a 
        corresponding output file for each in the designated output directory, 
        with the output file suffix optionally specified by the <tt>-otyp</tt> 
        option. </p>
      <h2>TUTORIAL EXAMPLES<a name="tut"></a> <a href="#0" class="aa">top</a></h2>
      <p> For a simple example, consider first the following command line:<br>
        <tt>gema 'Abram=Abraham;Sarai=Sarah' old.text new.text</tt><br>
        This copies file "old.text" to "new.text", replacing each occurrence of 
        the string "Abram" with the string "Abraham" and replacing "Sarai" with 
        "Sarah". The first command line argument consists of two transformation 
        rules separated by '<tt>;</tt>'. Each rule consists of a <i>template</i> 
        followed by '<tt>=</tt>' and an <i>action</i>. Any text that matches a 
        template is replaced by the result of the corresponding action. (Here 
        the action is just a literal replacement string, but it is called an <i>action</i> 
        instead of a <i>replacement</i> because it is more general than that.) 
        The presence of the equal sign serves to distinguish a pattern argument 
        from a file name. Note that pattern arguments will usually need to be 
        enclosed in single quotes on Unix, or double quotes on MS-DOS. </p>
      <p>Patterns can also be defined in one or more files loaded with the <tt>-f</tt> 
        option. In a pattern file, new lines separate rules, blank lines are ignored, 
        and a '<tt>!</tt>' causes the rest of the line to be ignored as a comment. 
        The following characters have special meaning in patterns:<br>
        <tt>: * ? # / &lt; &gt; \ ^ = $ @ { } ; !</tt> Space NewLine </p>
      <p>Usually when doing string replacement we need to be a little more careful. 
        For example, suppose we want to replace the variable name "x" with the 
        name "horizontal". We don't want to replace instances of "x" that appear 
        as parts of words, only those that are a word by themselves. This can 
        easily be done like this:<br>
        <tt>gema -t 'x=horizontal'</tt> ...<br>
        where the <tt>-t</tt> option (token mode) requires all identifiers in 
        templates to match a complete identifier in the input data. If you don't 
        want this behavior everywhere, it can instead be specified locally in 
        the template like this:<br>
        <tt>gema '\Ix\I=horizontal'</tt> ...<br>
        Here the notation "<tt>\I</tt>" denotes an identifier delimiter; it matches 
        an empty string but only if one of the adjacent characters can not be 
        part of an identifier. There are a number of other such operators listed 
        in the reference section below. Another that is particularly useful is 
        "<tt>\W</tt>", which says that any number of whitespace characters will 
        be accepted and skipped over if they appear at that point. Thus a template 
        like "<tt>x\W+\Wy</tt>" will match regardless of whether the input text 
        contains optional spaces. The <tt>-w</tt> option may be used to ignore 
        spaces everywhere (except within identifiers or numbers). </p>
      <p>A template such as "<tt>first down</tt>" will not only match these two 
        words separated by a space, it will also match if they are separated by 
        multiple spaces or even by a newline. This is because the space character 
        actually has special meaning, which is to match one or more whitespace 
        characters. In the less likely event that you really want to match exactly 
        one space character, you can use "<tt>\ </tt>" or "<tt>\s</tt>". </p>
      <p>Templates can also have <i>arguments</i> -- i.e. portions which match 
        variable text. There are in fact several different kinds of arguments 
        supported. The first kind of argument is the <i>wild card</i> characters 
        "<tt>*</tt>", which matches any number of characters (up to a limit that 
        can be adjusted by the <tt>-arglen</tt> option), and "<tt>?</tt>", which 
        matches any one character. For example, consider the C macro definition:<br>
        <tt>#define frob(p,m) do(Frob,p[m])</tt><br>
        A first approximation to doing this with <tt>gema</tt> is to use a rule 
        like this: "<tt>\Ifrob\W(*,*)=do(Frob,*[*])</tt>" Here the asterisks in 
        the template match any text up to the delimiting comma or parenthesis, 
        and the same text is substituted where the asterisks appear in the action. 
        Note though that in <tt>gema</tt>, the comma and parentheses do not have 
        any special meaning; a template may delimit the arguments with whatever 
        characters you want. There may be as many as 20 arguments, and the "<tt>*</tt>" 
        or "<tt>?</tt>" in the action will be substituted in the same order as 
        in the template. In cases where the arguments need to be used in some 
        different order or an argument needs to be used more than once, a different 
        notation may be used that designates the arguments by number. For example:<br>
        Rule: <tt>ADD * TO *.=$2 \:\= $2 + $1\;</tt><br>
        Input: <tt>ADD ITEM TO SUM.</tt><br>
        Output: <tt>SUM := SUM + ITEM;</tt><br>
        Note that some of the characters are escaped so that they will be treated 
        as literals. A backslash preceding a special character always means that 
        the character is to be taken literally, so it won't hurt to escape all 
        special character literals if you aren't sure which ones have special 
        meaning. (If there are more than nine arguments, the number needs to be 
        enclosed in braces, like: "<tt>${10}</tt>") </p>
      <p>One problem to watch out for with "<tt>*</tt>" arguments is that since 
        <tt>gema</tt> allows patterns to span line boundaries, the argument may 
        read many lines ahead, gobbling up much more text than intended. In cases 
        where you want to match only on a single line, the operator "<tt>\L</tt>" 
        can be used in a template to specify that the following arguments will 
        not be allowed to match on a newline character. This mode may also be 
        selected globally with the command line option <tt>-line</tt>. </p>
      <p>When a template is to match an entire line, the first inclination might 
        be to write a template such as: "<tt>\nCommand *\n</tt>" where "<tt>\n</tt>" 
        designates the new line character. But there are two problems with this: 
        it won't match on the first line of the file (because there isn't a preceding 
        new line) and it won't match on lines where the preceding new line has 
        already been read as part of the match for the previous line. Both of 
        these are solved by using "<tt>\N</tt>" which matches if it is at the 
        beginning or end of a line, but doesn't actually read the new line character. 
        In an action, "<tt>\N</tt>" outputs a new line character if the output 
        stream is not already at the beginning of a line. </p>
      <p>Another way to further constrain argument matching is to use the next 
        kind of argument, which is called a <i>predefined recognizer domain</i>. 
        (We'll see user-defined domains later.) For example, in a template the 
        string "<tt>&lt;D&gt;</tt>" designates an argument that will match one 
        or more digits. Similarly, "<tt>&lt;L&gt;</tt>" matches one or more letters, 
        "<tt>&lt;I&gt;</tt>" matches an identifier (letters, digits, and underscore), 
        and "<tt>&lt;N&gt;</tt>" matches a number (digits with optional sign and 
        decimal point). Other kinds are listed in the reference section below. 
        With a lower case letter, the argument becomes optional. Thus, "<tt>&lt;d&gt;</tt>" 
        matches zero or more digits. Preceding the letter with a minus sign inverts 
        the test, so that, for example, "<tt>&lt;-D&gt;</tt>" matches one or more 
        characters that are <i>not</i> digits. The letter may be followed by a 
        number to limit how many characters are matched. For example, "<tt>&lt;D3&gt;</tt>" 
        matches exactly three digits and "<tt>&lt;d3&gt;</tt>" will match from 
        zero up to a maximum of three digits. A <i>universal</i> argument such 
        as "<tt>&lt;U10&gt;</tt>" matches exactly 10 characters of any kind; this 
        may be useful for splitting an input record into fixed-length fields. 
        Note that "<tt>&lt;U1&gt;</tt>" is equivalent to "<tt>?</tt>". (For these 
        arguments, the action must access the value using "<tt>$</tt>" instead 
        of repeating the argument designator. That short cut is only supported 
        for arguments designated by a single character.) </p>
      <p>An even more general way of specifying the set of characters to be accepted 
        is to use a <i>regular expression</i>. A regular expression argument is 
        designated by slashes before and after. For example, the template "<tt>c/[ad]+/r</tt>" 
        will match input text "cadar" with "<tt>$1</tt>" having the value "ada". 
        Note that between the slashes, the special characters have the meaning 
        defined by the usual regular expression syntax, not their meaning elsewhere 
        in templates. </p>
      <p>The last kind of argument is a <i>recursive argument</i>. To show the 
        need for this, first consider this example that is trying to convert Lisp 
        s-expressions to function call notation:<br>
        Rule: <tt>(* * *)=*(*,*)</tt><br>
        Input: <tt>(fn xyz 34)</tt><br>
        Output: <tt>fn(xyz,34)</tt><br>
        So far, so good, but look what happens here:<br>
        Input: <tt>(fn (g a b) z)</tt><br>
        Output: <tt>fn((g,a b)</tt><br>
        What is needed is a way to properly associate matching nested parentheses 
        and to translate nested constructs. Both of these are done by simply modifying 
        the rule like this:<br>
        Rule: <tt>(# # #)=#(#,#)</tt><br>
        Input: <tt>(fn (g a b) z)</tt><br>
        Output: <tt>fn(g(a,b),z)</tt><br>
        The "<tt>#</tt>" designates a <i>recursive argument</i>, which means that 
        the argument value is the result of translating input text until reaching 
        the terminator character(s) following it. The space following "g" does 
        not terminate the outer-level argument because it is read as part of the 
        inner-level template match. Similarly, the inner "(" is read by the inner 
        match which also reads the matching inner ")". </p>
      <p>Actions can also perform a wide variety of activities by using the large 
        set of built-in functions that are available. A function call is designated 
        by "<tt>@</tt>" followed by the name of the function, followed by any 
        arguments enclosed in curly braces and separated by semicolons. The "functions" 
        section below lists all of the functions that are available. For example, 
        you can define a default rule like this: "<tt>\N.*\N=@err{@file line @line\: 
        Unrecognized\: $1}</tt>" The <tt>err</tt> function writes its argument 
        to the error output stream. The <tt>file</tt> and <tt>line</tt> functions 
        (which have no arguments) return the name and line number of the input 
        file. </p>
      <p><tt>gema</tt> supports defining multiple sets of rules, each of which 
        is called a <i>domain.</i> By default, rules are defined in the default 
        domain, which is also the one used to translate the input file. Alternate 
        domains are created by prefixing a rule with a domain name followed by 
        "<tt>:</tt>". The domain name applies until the end of the line. The name 
        of the default domain is the empty string, so a rule line beginning with 
        a colon is the same as one without any colon. Alternate domains are used 
        for several purposes, including defining new kinds of arguments for use 
        in templates, defining new functions for use in actions, and for translations 
        that require different rules for various contexts in the input data. </p>
      <p>To illustrate using an alternate domain as a new argument type, suppose 
        we want a template argument that will match on either "yes" or "no", so 
        that we can write a rule like:<br>
        <tt>done\? &lt;yesno&gt;=Finished \= $1</tt> <br>
        All that is needed is to define the following:<br>
        <tt>yesno:yes=yes@end;no=no@end;=@fail</tt> <br>
        This says that if you see "yes" or "no", output it to the argument value 
        and then return, and if anything is seen that doesn't match either of 
        those, then the argument match fails. Note that the last rule has an empty 
        template; this matches as a last resort if no other template in the domain 
        can be matched. Since it doesn't advance the input stream, this makes 
        sense only if the action is to exit. Note that domain names should have 
        at least two letters in order to not conflict with predefined recognizers. 
      </p>
      <p>Domain names can also be used as functions of one argument, which means 
        that the function returns the result of translating the argument value 
        with the patterns of the domain. This is typically used in a two-step 
        translation process where the first pattern match is used to split the 
        input into fields, and then other domains are used to process individual 
        fields. Remember that the default domain has an empty name, so "<tt>@{</tt><i>arg</i><tt>}</tt>" 
        means to translate the argument with the default domain. </p>
      <p>For an example of the use of alternate domains for different contexts, 
        suppose that we are doing name substitution in C source code and we don't 
        want to make any changes inside of character strings. We could add a rule 
        "<tt>"*"="*"</tt>" to match on string constants and pass them through. 
        However, string constants can contain "<tt>\"</tt>" and we don't want 
        the argument to be terminated by that quote. To handle this, we can use 
        a separate domain for processing the contents of a string. Then the rule 
        becomes "<tt>"&lt;sbody&gt;"="$1"</tt>" and we add a rule: "<tt>sbody:\\"=\\"</tt>" 
      </p>
      <p> </p>
      <h2>OPTIONS<a name="opt"></a> <a href="#0" class="aa">top</a></h2>
      <p> 
      <dl>
        <dt><tt>-f</tt><i> pattern_file</i> 
        <dd>Reads pattern definitions from a file. <br>
          &nbsp;</dd>
        <dt><tt>-p</tt><i> patterns</i> 
        <dd>Patterns defined directly as a command line argument. The <tt>-p</tt> 
          can usually be omitted since an argument containing "<tt>=</tt>" or 
          beginning with "<tt>@</tt>" is automatically recognized as a pattern 
          argument. <br>
          &nbsp;</dd>
        <dt><tt>-in</tt><i> file</i> 
        <dd>Explicitly specifies the input file pathname. If the file name is 
          "<tt>-</tt>" then standard input is used. Usually the <tt>-in</tt> is 
          not necessary since the first file name on the command line is understood 
          to be the input file. <br>
          &nbsp;</dd>
        <dt><tt>-out</tt><i> file</i> 
        <dd>Specifies the pathname of the output file. If the name is "<tt>-</tt>" 
          then standard output is used. After an explicit <tt>-out</tt> option 
          has been used, the remainder of the command line can have any number 
          of input file names (without <tt>-in</tt>) which will be read in sequence, 
          with the concatenated result going to the single output file. For example, 
          a command such as the following can be used to do a <tt>grep</tt>-like 
          search of a group of files:<br>
          <tt>gema -match -p 'Copyright *\n=@file\: $0' -out - *.c</tt><br>
          <br>
          &nbsp;</dd>
        <dt><tt>-odir</tt><i> directory</i> 
        <dd>Specifies the output directory. For each input file that follows, 
          a corresponding output file will be written in the designated directory. 
          <br>
          &nbsp;</dd>
        <dt><tt>-otyp</tt><i> suffix</i> 
        <dd>When used with the <tt>-odir</tt> option, this specifies that each 
          output file will have the designated suffix replacing the suffix of 
          the input file. For example, given the command line:<br>
          <tt>gema -f patterns -odir /stuff -otyp .list *.text</tt><br>
          then if the current directory contains a file named "<tt>foo.text</tt>", 
          it will be translated to an output file named "<tt>/stuff/foo.list</tt>". 
          <br>
          &nbsp;</dd>
        <dt><tt>-backup</tt><i> suffix</i> 
        <dd>The argument will be used as the backup file suffix in place of the 
          default "<tt>.bak</tt>". <br>
          &nbsp;</dd>
        <dt><tt>-nobackup</tt> 
        <dd>Output files will be overwritten instead of saving the old file as 
          a backup file. <br>
          &nbsp;</dd>
        <dt><tt>-line</tt> 
        <dd>Places the program in line mode, which means that all pattern matching 
          is limited to single lines. Arguments and template operators will never 
          cross a line boundary except where the template explicitly specifies 
          so with "<tt>\n</tt>". <br>
          &nbsp;</dd>
        <dt><tt>-b</tt> 
        <dd>Binary. With this option, all input and output files are opened in 
          binary mode instead of text mode. This makes no difference on most Unix 
          systems, but on MS-DOS it changes the meaning of the new line character 
          and doesn't treat Control-Z as the end of the file. <br>
          &nbsp;</dd>
        <dt><tt>-k</tt> 
        <dd>Keep going. With this option, the program will try to continue execution 
          after certain errors that would normally cause it to abort. This may 
          be useful when you want to see everything that is wrong before starting 
          to fix the errors. Errors will still cause a non-zero exit status despite 
          this option. <br>
          &nbsp;</dd>
        <dt><tt>-match</tt> 
        <dd>Matches only mode. Input text that doesn't match any template will 
          be discarded instead of being copied to the output. This would be used 
          when you want to extract selected information (like with <tt>grep</tt>) 
          instead of doing a translation. This option applies only to the default 
          domain. Another way to discard otherwise unmatched text is with the 
          default rule "<tt>?=</tt>" while the rule "<tt>?=?</tt>" can be used 
          to explicitly copy. <br>
          &nbsp;</dd>
        <dt><tt>-i</tt> 
        <dd>Case insensitive mode. All letters in templates will be matched without 
          regard to distinctions of upper case or lower case. This also makes 
          the names of domains and built-in functions case insensitive. <br>
          &nbsp;</dd>
        <dt><tt>-w</tt> 
        <dd>Whitespace insensitive mode. Space and tab characters in rules will 
          be ignored except where they separate identifiers. Template matching 
          will ignore whitespace characters in the input data as though templates 
          had an implicit "<tt>\W</tt>" everywhere except within identifiers. 
          Templates can use "<tt>\J</tt>" to indicate where space is <i>not</i> 
          allowed. <br>
          &nbsp;</dd>
        <dt><tt>-t</tt> 
        <dd>Token mode. All identifiers appearing in templates will match only 
          against a complete identifier, as though each identifier was implicitly 
          surrounded by "<tt>\I</tt>" except where counter-acted by "<tt>\J</tt>". 
          <br>
          &nbsp;</dd>
        <dt><tt>-idchars</tt><i> charset</i> 
        <dd>Identifier characters. The argument value specifies the set of characters 
          that will be considered to be identifier constituents, in addition to 
          letters and digits. The default value is "<tt>_</tt>". This affects 
          the behavior of "<tt>\I</tt>", "<tt>&lt;I&gt;</tt>", and "<tt>&lt;Y&gt;</tt>", 
          and the <tt>-w</tt> and <tt>-t</tt> options. For example, if you were 
          processing COBOL source code, you would need "<tt>-idchars '-'</tt>". 
          For Lisp code, you would probably want something like: "<tt>-idchars 
          '-+=*/_&lt;&gt;'</tt>" <br>
          &nbsp;</dd>
        <dt><tt>-filechars</tt><i> charset</i> 
        <dd>File name characters. The argument value specifies the set of characters 
          which are accepted by "<tt>&lt;F&gt;</tt>" as being file name constituents, 
          in addition to letters and digits. The default value is "<tt>./-_~#@%+=</tt>" 
          for Unix. On MS-DOS, colon and backslash are also included in the default 
          set. <br>
          &nbsp;</dd>
        <dt><tt>-literal</tt><i> charset</i> 
        <dd>This option specifies that each of the characters in the argument 
          value will be treated as an ordinary literal character in patterns, 
          instead of whatever special meaning it might normally have. For example, 
          rather than saying something like:<br>
          <tt>gema '\/usr\/foo\/&lt;F&gt;=\/usr\/bar\/$1'</tt> <i>...</i><br>
          you could instead say:<br>
          <tt>gema -literal / '/usr/foo/&lt;F&gt;=/usr/bar/$1'</tt> <i>...</i> 
          <br>
          &nbsp;</dd>
        <dt><tt>-ml</tt>
        <dd>For convenience in processing Markup Languages (HTML, XML, etc.), 
          this<br>
          option (which is new in version 1.4) changes the syntax so that the 
          characters<br>
          <code>&lt;</code> , <code>&gt;</code> and <code>/</code> are taken as 
          literals, using <code>[</code> , <code>]</code> and <code>|</code> respectively 
          in their places. <br>
          For example:<br>
          <br>
          <code> &nbsp;&nbsp;&nbsp;&nbsp;gema -ml -p '&lt;i&gt;[T]&lt;/i&gt;=&lt;em&gt;$1&lt;/em&gt;' 
          <em>...</em></code><br>
          <br>
          has the same effect as:<br>
          <code><br>
          &nbsp;&nbsp;&nbsp;&nbsp;gema -p '\&lt;i\&gt;&lt;T&gt;\&lt;\/i\&gt;=\&lt;em\&gt;$1\&lt;\/em\&gt;' 
          <em>...</em></code><br>
          <br>
          The <code>-ml</code> option is an abbreviation for <tt>@set-syntax{&lt;/&gt;LLL;[|]&lt;/&gt;}</tt>.<br>
          &nbsp;</dd>
        <dt><tt></tt>
        <dt><tt>-arglen</tt><i> number</i> 
        <dd>Specify the maximum length of a "<tt>*</tt>" argument. The default 
          is 4096. <br>
          &nbsp;</dd>
        <dt><tt>-prim</tt><i> pattern_file</i> 
        <dd>Primitive mode (for advanced users only). Like the <tt>-f</tt> option, 
          this loads patterns from a file. It also suppresses loading of the built-in 
          patterns for command line processing. This option is meaningful only 
          when it appears as the first argument, and then it becomes the only 
          argument that has any predefined meaning. The designated pattern file 
          must define <tt>ARGV</tt> domain rules sufficient to specify what to 
          do with the remainder of the command line. <br>
          &nbsp;</dd>
        <dt><tt>-help</tt> 
        <dd>Display brief usage message on the standard error output. <br>
          &nbsp;</dd>
        <dt><tt>-version</tt> 
        <dd>Display program version identification on the standard error output. 
          <br>
          &nbsp;</dd>
        <dt><tt>-trace</tt> </dt>
        <dd>If the program was compiled with <tt>-DTRACE,</tt> then this option 
          can be used to enable a report of template matches and failures to be 
          written to the error output. This may be helpful for diagnosing obscure 
          cases of unexpected results, but this is a crude experimental feature, 
          so don't expect too much. Each line describes one event, possibly showing 
          the line and column number at the beginning of the current template, 
          the line and column of the current position, and a description of the 
          event, indented for recursive arguments. </dd>
        <br>
        &nbsp;</dd> 
        <dt>&nbsp; 
      </dl>
      <h2>PATTERNS REFERENCE SUMMARY<a name="pat"></a> <a href="#0" class="aa">top</a></h2>
      The following characters have special meaning: 
      <p> 
      <dl>
        <dt><tt>*</tt> 
        <dd>matches any number of characters 
        <dt><tt>?</tt> 
        <dd>matches any one character 
        <dt><tt>#</tt> 
        <dd>argument recursively translated in the current domain 
        <dt><tt>=</tt> 
        <dd>end of template, beginning of action 
        <dt><tt>$0</tt> 
        <dd>copies the template into the action to show all matched text 
        <dt><tt>$</tt><i>digit</i> 
        <dd>inserts argument value 
        <dt><tt>$</tt><i>letter</i> 
        <dd>inserts value of a variable with single-letter name 
        <dt><tt>${</tt><i>name</i><tt>}</tt> 
        <dd>value of named variable (only in action) 
        <dt><tt>${</tt><i>name</i><tt>;</tt><i>default</i><tt>}</tt> 
        <dd>variable with default value if not defined (action only) 
        <dt><tt>\</tt> 
        <dd>escape character; see the section on "escape sequences" below. 
        <dt><tt>^</tt><i>x</i> 
        <dd>combine control key with the following character 
        <dt><i>Space</i> 
        <dd>matches one or more whitespace characters (same as "<tt>\S</tt>"). 
        <dt><i>NewLine</i> 
        <dd>end of action 
        <dt><tt>;</tt> 
        <dd>end of action, or separator between function arguments 
        <dt><tt>@</tt><i>name</i><tt>{</tt><i>args</i><tt>}</tt> 
        <dd>invoke built-in function or user-defined translation domain (action 
          only) 
        <dt><tt>@</tt><i>special-character</i> 
        <dd>has the default meaning of the special character by itself, as documented 
          here; this can be used to access the original functionality of a character 
          that has been changed by the <tt>-literal</tt> option or <tt>@set-syntax</tt> 
          function. 
        <dt><tt>:</tt> 
        <dd>separates domain name from rule 
        <dt><tt>&lt;</tt><i>name</i><tt>&gt;</tt> 
        <dd>recursive argument, translated according to the named domain, or pre-defined 
          recognizer argument. (template only) 
        <dt><tt>/</tt><i>regexp</i><tt>/</tt> 
        <dd>regular expression argument (template only) 
        <dt><tt>!</tt> 
        <dd>the rest of the line is a comment </dd>
      </dl>
      <p>Also, as a special case, the first line of a pattern file is ignored 
        if the first two characters are "<tt>#!</tt>". This allows a pattern file 
        to be made directly executable by putting something like "<tt>#!/usr/local/bin/gema 
        -f</tt>" as the first line. 
      <p> 
      <h2>ESCAPE SEQUENCES<a name="esc"></a> <a href="#0" class="aa">top</a></h2>
      <p>The backslash character denotes special handling for the character that 
        follows it. When followed by a lower-case letter or a digit, it represents 
        a particular control character. When followed by an upper case letter, 
        it is a pattern match operator. A backslash at the end of a line designates 
        continuation by causing the newline to be ignored along with any leading 
        white space on the following line. Before any other character, the backslash 
        quotes the character so that it simply represents itself. In particular, 
        a literal backslash is represented by two backslashes. </p>
      <p>Following are the defined escape sequences: </p>
      <p> </p>
      <dl>
        <dt><tt>\a</tt> 
        <dd>Alert (a.k.a. bell) character 
        <dt><tt>\b</tt> 
        <dd>Backspace character 
        <dt><tt>\c</tt><i>x</i> 
        <dd>Control key combined with the following character 
        <dt><tt>\d</tt> 
        <dd>Delete character 
        <dt><tt>\e</tt> 
        <dd>Escape character (i.e. ESC, not backslash) 
        <dt><tt>\f</tt> 
        <dd>Form feed character 
        <dt><tt>\n</tt> 
        <dd>New line character 
        <dt><tt>\r</tt> 
        <dd>carriage Return character 
        <dt><tt>\s</tt> 
        <dd>Space character 
        <dt><tt>\t</tt> 
        <dd>horizontal Tab character 
        <dt><tt>\v</tt> 
        <dd>Vertical tab character 
        <dt><tt>\x</tt><i>xx</i> 
        <dd>character specified by its heXadecimal code 
        <dt><tt>\</tt><i>digits</i> 
        <dd>character specified by its octal code 
        <dt><tt>\A</tt> 
        <dd>matches beginning of input data 
        <dt><tt>\B</tt> 
        <dd>matches Beginning of file 
        <dt><tt>\C</tt> 
        <dd>Case-insensitive comparison for the rest of the template 
        <dt><tt>\E</tt> 
        <dd>matches End of file 
        <dt><tt>\G</tt> 
        <dd>Goal -- complete preceding argument before considering rest of template 
        <dt><tt>\I</tt> 
        <dd>Identifier separator 
        <dt><tt>\J</tt> 
        <dd>Join -- locally counteracts the <tt>-w</tt> and/or <tt>-t</tt> option 
          by saying that spaces in the input will not be ignored at this position, 
          and an identifier delimiter is not required here. If neither of these 
          options is being used, then it has no effect. 
        <dt><tt>\L</tt> 
        <dd>Line mode -- following arguments can't cross line boundary 
        <dt><tt>\N</tt> 
        <dd>New line; matches beginning or end of line 
        <dt><tt>\P</tt> 
        <dd>Position -- leave input stream here after the template matches 
        <dt><tt>\S</tt> 
        <dd>Space -- matches one or more whitespace characters 
        <dt><tt>\W</tt> 
        <dd>Whitespace -- skips over any optional whitespace characters 
        <dt><tt>\X</tt> 
        <dd>word separator 
        <dt><tt>\Z</tt> 
        <dd>matches end of input data </dd>
      </dl>
      <p> </p>
      <h2>RECOGNIZERS<a name="rec"></a> <a href="#0" class="aa">top</a></h2>
      <p>The following argument designators, consisting of a single letter between 
        angle brackets, can be used in templates to match on various kinds of 
        characters. Preceding the letter with "<tt>-</tt>" inverts the test. The 
        argument requires at least one matching character if the letter is uppercase, 
        or is optional if the letter is lowercase. The letter may be followed 
        by a number to match on that many characters, or up to that maximum for 
        an optional argument. If the number is <tt>0</tt>, the argument matches 
        if the next character is of the indicated kind, but the input stream is 
        not advanced past it; in other words, this acts as a one-character look-ahead. 
      <dl>
        <dt><tt>&lt;A&gt;</tt> 
        <dd>Alphanumeric (letters and digits) 
        <dt><tt>&lt;C&gt;</tt> 
        <dd>Control characters 
        <dt><tt>&lt;D&gt;</tt> 
        <dd>Digits 
        <dt><tt>&lt;F&gt;</tt> 
        <dd>File pathname 
        <dt><tt>&lt;G&gt;</tt> 
        <dd>Graphic characters, i.e. any non-space printable character 
        <dt><tt>&lt;I&gt;</tt> 
        <dd>Identifier 
        <dt><tt>&lt;J&gt;</tt> 
        <dd>lower case letters 
        <dt><tt>&lt;K&gt;</tt> 
        <dd>upper case letters 
        <dt><tt>&lt;L&gt;</tt> 
        <dd>Letters (either upper or lower case) 
        <dt><tt>&lt;N&gt;</tt> 
        <dd>Number, i.e. digits with optional sign and decimal point 
        <dt><tt>&lt;O&gt;</tt> 
        <dd>Octal digits 
        <dt><tt>&lt;P&gt;</tt> 
        <dd>Printing characters, including space 
        <dt><tt>&lt;S&gt;</tt> 
        <dd>white Space characters (space, tab, newline, FF, VT) 
        <dt><tt>&lt;T&gt;</tt> 
        <dd>Text characters, including all printing characters and white space 
        <dt><tt>&lt;U&gt;</tt> 
        <dd>Universal (matches anything except end-of-file) 
        <dt><tt>&lt;W&gt;</tt> 
        <dd>Word (letters, apostrophe, and hyphen) 
        <dt><tt>&lt;X&gt;</tt> 
        <dd>hexadecimal digits 
        <dt><tt>&lt;Y&gt;</tt> 
        <dd>punctuation (graphic characters that are not identifiers) </dd>
        <br>&nbsp;</dd>
      </dl>
      <h2>GEMA FUNCTIONS<a name="fun"></a> <a href="#0" class="aa">top</a></h2></p>
      The following built-in functions may be used in actions, either in the action 
      portion of a rule, or appearing by itself as an immediate action. When a 
      line in a pattern file begins with "<tt>@</tt>", the actions are executed 
      before reading the next line. </p> <p>Function calls have the form "<tt>@</tt><i>name</i><tt>{</tt><i>args</i><tt>}</tt>", 
        with arguments separated by "<tt>;</tt>". For functions without arguments, 
        the argument delimiters "<tt>{}</tt>" may be omitted if not needed to 
        separate the name from the following character. All arguments are evaluated, 
        so all of the special characters available in actions apply within the 
        arguments also. (In a few cases, arguments that are not used are skipped 
        instead of evaluated, but arguments are never used literally.) Arguments 
        shown as <i>number</i> or <i>length</i> must have a value which is a valid 
        decimal representation of an integer, with optional leading whitespace 
        and optional sign. All numbers are considered to be 32 bit signed integers. 
        The descriptions given here for the functions is just a terse reference 
        summary; refer to the user manual for more detailed information. </p>
      
      <dl>
        <dt><tt>@abort{}</tt> 
        <dd>Immediately terminate execution. <br>
          &nbsp;</dd>
        <dt><tt>@add{</tt><i>number</i><tt>;</tt><i>number</i><tt>}</tt> 
        <dd>Return the sum of the two numbers. <br>
          &nbsp;</dd>
        <dt><tt>@and{</tt><i>number</i><tt>;</tt><i>number</i><tt>}</tt> 
        <dd>Return the bit-wise <i>and</i> of the two numbers. <br>
          &nbsp;</dd>
        <dt><tt>@append{</tt><i>var</i><tt>;</tt><i>string</i><tt>}</tt> 
        <dd>Append the string to the end of the named variable's value. No return 
          value. <br>
          &nbsp;</dd>
        <dt><tt>@bind{</tt><i>var</i><tt>;</tt><i>string</i><tt>}</tt> 
        <dd>Bind named variable to a value. No return value. <br>
          &nbsp;</dd>
        <dt><tt>@center{</tt><i>length</i><tt>;</tt><i>string</i><tt>}</tt> 
        <dd>Center the string within a field of the designated length. <br>
          &nbsp;</dd>
        <dt><tt>@char-int{</tt><i>character</i><tt>}</tt> 
        <dd>Returns decimal number representation of internal character code. 
          <br>
          &nbsp;</dd>
        <dt><tt>@close{</tt><i>pathname</i><tt>}</tt> 
        <dd>Closes a file previously opened by <tt>@write{</tt><i>pathname</i><tt>}</tt> 
          <br>
          &nbsp;</dd>
        <dt><tt>@cmpi{</tt><i>string</i><tt>;</tt><i>string</i><tt>;</tt><i>less-value</i><tt>;</tt><i>equal-value</i><tt>;</tt><i>greater-value</i><tt>}</tt> 
        <dd>Compare, case-insensitive. Return either the third, fourth, or fifth 
          argument value depending on whether the first argument is less than, 
          equal to, or greater than the second. The two unused arguments are not 
          evaluated. <br>
          &nbsp;</dd>
        <dt><tt>@cmpn{</tt><i>number</i><tt>;</tt><i>number</i><tt>;</tt><i>less-value</i><tt>;</tt><i>equal-value</i><tt>;</tt><i>greater-value</i><tt>}</tt> 
        <dd>Compare numbers. <br>
          &nbsp;</dd>
        <dt><tt>@cmps{</tt><i>string</i><tt>;</tt><i>string</i><tt>;</tt><i>less-value</i><tt>;</tt><i>equal-value</i><tt>;</tt><i>greater-value</i><tt>}</tt> 
        <dd>Compare, case-sensitive. <br>
          &nbsp;</dd>
        <dt><tt>@column{}</tt> 
        <dd>Returns the current column number in the input stream. <br>
          &nbsp;</dd>
        <dt><tt>@date{}</tt> 
        <dd>Returns the current date, in the form <i>mm</i>/<i>dd</i>/<i>yyyy</i> 
          <br>
          &nbsp;</dd>
        <dt><tt>@datime{}</tt> 
        <dd>Returns the current date and time, formatted by the C function <tt>ctime</tt>(3). 
          <br>
          &nbsp;</dd>
        <dt><tt>@decr{</tt><i>var</i><tt>}</tt> 
        <dd>Decrement value of variable. No return value. <br>
          &nbsp;</dd>
        <dt><tt>@define{</tt><i>patterns</i><tt>}</tt> 
        <dd>Run-time definition of additional rules. No return value. <br>
          &nbsp;</dd>
        <dt><tt>@div{</tt><i>number</i><tt>;</tt><i>number</i><tt>}</tt> 
        <dd>Return result of dividing the first argument by the second. <br>
          &nbsp;</dd>
        <dt><tt>@downcase{</tt><i>string</i><tt>}</tt> 
        <dd>Convert any letters from upper case to lower case. <br>
          &nbsp;</dd>
        <dt><tt>@end{}</tt> 
        <dd>End translation. No return value. <br>
          &nbsp;</dd>
        <dt><tt>@err{</tt><i>string</i><tt>}</tt> 
        <dd>Write the argument value to the error output stream. No return value. 
          <br>
          &nbsp;</dd>
        <dt><tt>@exit-status{</tt><i>number</i><tt>}</tt> 
        <dd>Specify exit code to return when the program terminates. No return 
          value. <br>
          &nbsp;</dd>
        <dt><tt>@expand-wild{</tt><i>path</i><tt>}</tt> 
        <dd>Expand wild card pathname on MS-DOS. <br>
          &nbsp;</dd>
        <dt><tt>@fail{}</tt> 
        <dd>Signal translation failure; causes failed match of recursive argument. 
          <br>
          &nbsp;</dd>
        <dt><tt>@file{}</tt> 
        <dd>Returns the name of the input file. <br>
          &nbsp;</dd>
        <dt><tt>@file-time{}</tt> 
        <dd>Returns the modification time and date of the input file, formatted 
          by the C function <tt>ctime</tt>(3). <br>
          &nbsp;</dd>
        <dt><tt>@fill-center{</tt><i>background</i><tt>;</tt><i>value</i><tt>}</tt> 
        <dd>Center the value on top of the background string. <br>
          &nbsp;</dd>
        <dt><tt>@fill-left{</tt><i>background</i><tt>;</tt><i>value</i><tt>}</tt> 
        <dd>Left-justify the value on top of the background string. <br>
          &nbsp;</dd>
        <dt><tt>@fill-right{</tt><i>background</i><tt>;</tt><i>value</i><tt>}</tt> 
        <dd>Right-justify the value on top of the background string. <br>
          &nbsp;</dd>
        <dt><tt>@getenv{</tt><i>name</i><tt>;</tt><i>default</i><tt>}</tt> 
        <dd>Return the value of an environment variable. Returns the optional 
          second argument if the environment variable is not defined. <br>
          &nbsp;</dd>
        <dt><tt>@get-switch{</tt><i>name</i><tt>}</tt> 
        <dd>Return value of switch (see <tt>@set-switch</tt>) <br>
          &nbsp;</dd>
        <dt><tt>@incr{</tt><i>var</i><tt>}</tt> 
        <dd>Increments the value of a variable. No value returned. <br>
          &nbsp;</dd>
        <dt><tt>@inpath{}</tt> 
        <dd>Returns the pathname of the input file. <br>
          &nbsp;</dd>
        <dt><tt>@int-char{</tt><i>number</i><tt>}</tt> 
        <dd>Returns the character whose internal code is given by the argument. 
          <br>
          &nbsp;</dd>
        <dt><tt>@line{}</tt> 
        <dd>Returns the current line number in the input file. <br>
          &nbsp;</dd>
        <dt><tt>@left{</tt><i>length</i><tt>;</tt><i>string</i><tt>}</tt> 
        <dd>Left-justify the string, padding with spaces to the designated length. 
          <br>
          &nbsp;</dd>
        <dt><tt>@length{</tt><i>string</i><tt>}</tt> 
        <dd>Returns the length of the argument. <br>
        </dd>
        <dt>&nbsp;
        <dt><tt></tt> 
        <dt><tt>@makepath{</tt><i>directory</i><tt>;</tt><i>name</i><tt>;</tt><i>suffix</i><tt>}</tt> 
        <dd>Returns the file pathname formed by merging the second argument with 
          the default directory in the first argument and replacing the suffix 
          from the third argument, if not empty. <br>
          &nbsp;</dd>
        <dt><tt>@mergepath{</tt><i>pathname</i><tt>;</tt><i>name</i><tt>;</tt><i>suffix</i><tt>}</tt> 
        <dd>Returns the file pathname formed by merging the second argument with 
          a default directory extracted from the first argument and replacing 
          the suffix from the third argument, if not empty. <br>
          &nbsp;</dd>
        <dt><tt>@mul{</tt><i>number</i><tt>;</tt><i>number</i><tt>}</tt> 
        <dd>Returns the result of multiplying the two numbers. <br>
          &nbsp;</dd>
        <dt><tt>@mod{</tt><i>number</i><tt>;</tt><i>number</i><tt>}</tt> 
        <dd>Returns the first argument modulo the second. <br>
          &nbsp;</dd>
        <dt><tt>@not{</tt><i>number</i><tt>}</tt> 
        <dd>Returns the bit-wise inverse of the argument. <br>
          &nbsp;</dd>
        <dt><tt>@or{</tt><i>number</i><tt>;</tt><i>number</i><tt>}</tt> 
        <dd>Returns the bit-wise <i>or</i> of the two numbers. <br>
          &nbsp;</dd>
        <dt><tt>@out{</tt><i>string</i><tt>}</tt> 
        <dd>Writes the argument value directly to the current output file. No 
          return value. <br>
          &nbsp;</dd>
        <dt><tt>@out-column{}</tt> 
        <dd>Returns the current column number in the output file. <br>
          &nbsp;</dd>
        <dt><tt>@outpath{}</tt> 
        <dd>Returns the pathname of the output file. <br>
          &nbsp;</dd>
        <dt><tt>@push{</tt><i>var</i><tt>;</tt><i>value</i><tt>}</tt> 
        <dd>Set the value of a variable while remembering the previous value. 
          Same as <tt>@bind</tt>. <br>
          &nbsp;</dd>
        <dt><tt>@pop{</tt><i>var</i><tt>}</tt> 
        <dd>Restore the variable to the value it had before the most recent <tt>@push</tt>. 
          Same as <tt>@unbind</tt>. <br>
          &nbsp;</dd>
        <dt><tt>@probe{</tt><i>pathname</i><tt>}</tt> 
        <dd>Return "F" if the argument names a file, "D" if a directory, "V" if 
          a device, or "U" if undefined. <br>
          &nbsp;</dd>
        <dt><tt>@quote{</tt><i>string</i><tt>}</tt> 
        <dd>Returns a copy of the argument with backslashes inserted where necessary 
          so that <tt>@define</tt> will treat all of the characters as literals. 
          <br>
          &nbsp;</dd>
        <dt><tt>@radix{</tt><i>from</i><tt>;</tt><i>to</i><tt>;</tt><i>value</i><tt>}</tt> 
        <dd>Radix conversion. The first two arguments must be decimal integers. 
          The third argument is interpreted as a number whose base is specified 
          by the first argument. The result value is that number represented in 
          the base specified by the second argument. <br>
          &nbsp;</dd>
        <dt><tt>@read{</tt><i>pathname</i><tt>}</tt> 
        <dd>Return an input stream that reads the contents of the named file. 
          Note that this just specifies where the input comes from; it is usually 
          used as an argument to another function that specifies what to do with 
          the data. <br>
          &nbsp;</dd>
        <dt><tt>@relative-path{</tt><i>pathname</i><tt>;</tt><i>pathname</i><tt>}</tt> 
        <dd>If the two pathnames have the same directory portion, return the second 
          argument with the common directory removed; else return the whole second 
          argument. <br>
          &nbsp;</dd>
        <dt><tt>@repeat{</tt><i>number</i><tt>;</tt><i>action</i><tt>}</tt> 
        <dd>The second argument is executed the number of times specified by the 
          first argument. If the number is less than or equal to zero, the second 
          argument is not evaluated at all. <br>
          &nbsp;</dd>
        <dt><tt>@reset-syntax{}</tt> 
        <dd>Re-initializes the syntax tables to undo the effects of <tt>@set-syntax</tt> 
          or the <tt>-literal</tt> option. <br>
          &nbsp;</dd>
        <dt><tt>@reverse{</tt><i>string</i><tt>}</tt> 
        <dd>Return the characters of the argument in reverse order. <br>
          &nbsp;</dd>
        <dt><tt>@right{</tt><i>length</i><tt>;</tt><i>string</i><tt>}</tt> 
        <dd>Right-justify the string, padding with spaces to the designated length. 
          <br>
          &nbsp;</dd>
        <dt><tt>@set{</tt><i>var</i><tt>;</tt><i>value</i><tt>}</tt> 
        <dd>Set the named variable to the designated value. No return value. <br>
          &nbsp;</dd>
        <dt><tt>@set-locale{</tt><i>name</i><tt>}</tt> 
        <dd>Set internationalization locale, using <tt>setlocale</tt>(3). This 
          may affect which characters are considered to be letters, and the format 
          of times and dates. No result value. <br>
          &nbsp;</dd>
        <dt><tt>@set-parm{</tt><i>name</i><tt>;</tt><i>value</i><tt>}</tt> 
        <dd>Set a string-valued option, either "idchars", "filechars", or "backup". 
          No result value. <br>
          &nbsp;</dd>
        <dt><tt>@set-switch{</tt><i>name</i><tt>;</tt><i>value</i><tt>}</tt> 
        <dd>Set one of the following options to 1 for true or 0 for false: "line" 
          for line mode, "b" for binary mode, "k" to keep going after errors, 
          "match" for match-only mode, "i" for case-insensitive mode, "w" for 
          whitespace insensitive mode, "t" for token mode, or "trace". <br>
          &nbsp;</dd>
        <dt><tt>@set-syntax{</tt><i>type</i><tt>;</tt><i>charset</i><tt>}</tt> 
        <dd>The characters in the second argument will have the same meaning as 
          the corresponding special character(s) in the first argument, or use 
          one of the alphabetic type codes: "L" for literal, "I" for ignore, etc. 
          No result value. <br>
          &nbsp;</dd>
        <dt><tt>@set-wrap{</tt><i>number</i><tt>;</tt><i>string</i><tt>}</tt> 
        <dd>For <tt>@wrap</tt>, the first argument is the number of columns, and 
          the second argument is the indentation string. No result value. <br>
          &nbsp;</dd>
        <dt><tt>@shell{</tt><i>string</i><tt>}</tt> 
        <dd>The argument is executed as a shell command. No return value. <br>
          &nbsp;</dd>
        <dt><tt>@show-help{}</tt> 
        <dd>Display usage message on the standard error stream. <br>
          &nbsp;</dd>
        <dt><tt>@sub{</tt><i>number</i><tt>;</tt><i>number</i><tt>}</tt> 
        <dd>Subtract. <br>
          &nbsp;</dd>
        <dt><tt>@subst{</tt><i>patterns</i><tt>;</tt><i>operand</i><tt>}</tt> 
        <dd>Substitution. Return the result of translating the operand according 
          to the patterns temporarily defined by the first argument. <br>
          &nbsp;</dd>
        <dt><tt>@substring{</tt><i>skip</i><tt>;</tt><i>length</i><tt>;</tt><i>string</i><tt>}</tt> 
        <dd>Return substring of the third argument by skipping the number of characters 
          indicated by the first argument and then taking the number of characters 
          indicated by the second argument. <br>
          &nbsp;</dd>
        <dt><tt>@tab{</tt><i>number</i><tt>}</tt> 
        <dd>Output spaces until the output stream reaches the designated column. 
          <br>
          &nbsp;</dd>
        <dt><tt>@terminate{}</tt> 
        <dd>End translation of a recursive argument, with success if any characters 
          have been accepted, or failure if the argument value is empty. <br>
          &nbsp;</dd>
        <dt><tt>@time{}</tt> 
        <dd>Return the current time, in the form <i>hh</i>:<i>mm</i>:<i>ss</i> 
          <br>
          &nbsp;</dd>
        <dt><tt>@unbind{</tt><i>var</i><tt>}</tt> 
        <dd>Restore the variable to the value, if any, it had before the most 
          recent <tt>@bind</tt>. <br>
          &nbsp;</dd>
        <dt><tt>@undefine{</tt><i>patterns</i><tt>}</tt> 
        <dd>Delete pattern definitions. <br>
          &nbsp;</dd>
        <dt><tt>@upcase{</tt><i>string</i><tt>}</tt> 
        <dd>Convert any letters from lower case to upper case. <br>
          &nbsp;</dd>
        <dt><tt>@var{</tt><i>var</i><tt>;</tt><i>default</i><tt>}</tt> 
        <dd>Return the value of the named variable. If the variable is not defined, 
          return the optional second argument, if supplied, else report an error. 
          <tt>@var</tt> has the same effect as <tt>$</tt> when the name is not 
          a number. <br>
          &nbsp;</dd>
        <dt><tt>@version{}</tt> 
        <dd>Return the program version identification string. <br>
          &nbsp;</dd>
        <dt><tt>@wrap{</tt><i>string</i><tt>}</tt> 
        <dd>Output the string, after starting a new line if necessary according 
          to the parameters set by <tt>@set-wrap</tt>. The default is 80 columns 
          and no indentation. <br>
          &nbsp;</dd>
        <dt><tt>@write{</tt><i>pathname</i><tt>;</tt><i>string</i><tt>}</tt> 
        <dd>The second argument is evaluated with its result value being written 
          to the file named by the first argument. Subsequent calls to <tt>@write</tt> 
          with the same pathname will append to the file, until a <tt>@close</tt>. 
        </dd>
        <dt><br>
        </dt>
      </dl>
      <h2>BUGS<a name="bug"></a> <a href="#0" class="aa">top</a></h2>
      <p>The implementation of the <tt>-t</tt> and <tt>-w</tt> options is a little 
        sloppy and may produce unexpected results requiring use of explicit <tt>\J</tt>, 
        <tt>\I</tt>, or <tt>\W</tt> to work around in certain contexts.</p>
      <p></p>
      <h2>SEE ALSO<a name="aut"></a> <a href="#0" class="aa">top</a></h2>
      <p></p>
      The <tt>gema</tt> user manual and the example pattern files provided. 
      <p>All source files and documentation are available on Sourceforge: <a target="_blank" href="http://www.sourceforge.net/projects/gema">http://www.sourceforge.net/projects/gema</a></p>
      <h2>AUTHORS<a name="aut"></a> <a href="#0" class="aa">top</a></h2>
      <p><tt>gema</tt> was written by <em>David N. Gray</em><br>
        <br>
        Adapted for the Macintosh by <em>David A. Mundie</em><br>
        <br>
        <br>
        The <a href="links.html">link</a> page describes how to contact them. 
      </p>
      </td>
    <td width="2">&nbsp;</td>
    <td width="150" align="center" valign="top" class="tl"><img src="side.png" width="137" height="447" border="0" usemap="#Map"></td>
  </tr>
  <!--
  <tr><td  align="right" colspan="3" class="ssm"><font color="#CCCCCC" size="-1">Webdesign by Remo Dentato</font></td></tr>
  -->
</table>
<map name="Map">
  <area shape="rect" coords="7,32,132,69" href="http://sourceforge.net/projects/gema/" target="_blank">
  <area shape="rect" coords="36,141,107,200" href="http://opensource.org/docs/definition.php">
  <area shape="rect" coords="38,278,107,344" href="http://www.lua.org" target="_blank">
  <area shape="rect" coords="48,407,95,442" href="links.html">
</map>
</body>
</html>


